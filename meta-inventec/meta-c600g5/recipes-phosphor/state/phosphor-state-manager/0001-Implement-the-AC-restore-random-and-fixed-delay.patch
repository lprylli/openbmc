From bced3877a171d2c59376b9f6302fe68f45d22e40 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Chang=2EJamesWC=20=E5=BC=B5=E6=96=87=E9=87=91=20TAO?=
 <chang.jameswc@inventec.com>
Date: Thu, 11 Mar 2021 14:49:59 +0800
Subject: [PATCH] Implement the AC restore random and fixed delay

---
 discover_system_state.cpp | 73 +++++++++++++++++++++++++++++++++++++++
 1 file changed, 73 insertions(+)

diff --git a/discover_system_state.cpp b/discover_system_state.cpp
index 06a32c4..af46a19 100644
--- a/discover_system_state.cpp
+++ b/discover_system_state.cpp
@@ -17,6 +17,9 @@
 #include <map>
 #include <string>
 
+#include <chrono>
+#include <random>
+
 namespace phosphor
 {
 namespace state
@@ -183,6 +186,76 @@ int main(int argc, char** argv)
         RestorePolicy::convertPolicyFromString(powerPolicy))
     {
         log<level::INFO>("power_policy=ALWAYS_POWER_ON, powering host on");
+
+        auto method = bus.new_method_call(
+            settings.service(settings.powerRestorePolicy, powerRestoreIntf).c_str(),
+            settings.powerRestorePolicy.c_str(), "org.freedesktop.DBus.Properties",
+            "Get");
+        method.append(powerRestoreIntf, "PowerRestoreAlwaysOnPolicy");
+
+        std::variant<std::string> result;
+        try
+        {
+            auto reply = bus.call(method);
+            reply.read(result);
+        }
+        catch (const SdBusError& e)
+        {
+            log<level::ERR>("Error in PowerRestoreAlwaysOnPolicy Get",
+                            entry("ERROR=%s", e.what()));
+            elog<InternalFailure>();
+        }
+
+        auto powerAlwaysOnPolicy = std::get<std::string>(result);
+
+        if (RestorePolicy::AlwaysOnPolicy::Random ==
+            RestorePolicy::convertAlwaysOnPolicyFromString(powerAlwaysOnPolicy) ||
+            RestorePolicy::AlwaysOnPolicy::Fixed ==
+            RestorePolicy::convertAlwaysOnPolicyFromString(powerAlwaysOnPolicy))
+        {
+            auto method = bus.new_method_call(
+                settings.service(settings.powerRestorePolicy, powerRestoreIntf).c_str(),
+                settings.powerRestorePolicy.c_str(), "org.freedesktop.DBus.Properties",
+                "Get");
+            method.append(powerRestoreIntf, "PowerRestoreDelay");
+
+            std::variant<uint32_t> result;
+            try
+            {
+                auto reply = bus.call(method);
+                reply.read(result);
+            }
+            catch (const SdBusError& e)
+            {
+                log<level::ERR>("Error in PowerRestoreDelay Get",
+                                entry("ERROR=%s", e.what()));
+                elog<InternalFailure>();
+            }
+
+            auto powerRestoreDelay = std::get<uint32_t>(result);
+
+            if (RestorePolicy::AlwaysOnPolicy::Random ==
+                RestorePolicy::convertAlwaysOnPolicyFromString(powerAlwaysOnPolicy))
+            {
+                std::random_device rd;
+                std::default_random_engine gen = std::default_random_engine(rd());
+                std::uniform_int_distribution<int> dis(0,powerRestoreDelay);
+                powerRestoreDelay = dis(gen);
+            }
+
+            log<level::INFO>("Checking power always on policy and setting delay",
+                entry("POWER_ALWAYS_ON_POLICY=%s", powerAlwaysOnPolicy.c_str()),
+                entry("POWER_RESTORE_DELAY=%d", powerRestoreDelay));
+
+            std::this_thread::sleep_for (std::chrono::seconds(powerRestoreDelay));
+        }
+        else{
+            log<level::INFO>("Checking power always on policy",
+                entry("POWER_ALWAYS_ON_POLICY=%s", powerAlwaysOnPolicy.c_str()));
+        }
+
+        log<level::INFO>("power_policy=ALWAYS_POWER_ON, Starting power on");
+
         setProperty(bus, hostPath, HOST_BUSNAME, "RequestedHostTransition",
                     convertForMessage(server::Host::Transition::On));
     }
