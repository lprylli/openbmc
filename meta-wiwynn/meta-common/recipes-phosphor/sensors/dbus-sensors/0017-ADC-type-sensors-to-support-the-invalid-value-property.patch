From 72344f1b0995010270436da7959621648c4cb785 Mon Sep 17 00:00:00 2001
From: Frederick Lee <Frederick_Lee@wiwynn.com>
Date: Mon, 16 Dec 2019 17:38:51 +0800
Subject: [PATCH] ADC-type sensors to support the invalid value property

---
 src/ADCSensor.cpp | 54 ++++++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 49 insertions(+), 5 deletions(-)

diff --git a/src/ADCSensor.cpp b/src/ADCSensor.cpp
index 1f6d6f1..2d871ad 100644
--- a/src/ADCSensor.cpp
+++ b/src/ADCSensor.cpp
@@ -33,7 +33,7 @@
 #include <string>
 #include <vector>
 
-static constexpr unsigned int sensorPollMs = 500;
+static constexpr unsigned int sensorPollMs = 1000;
 static constexpr size_t warnAfterErrorCount = 10;
 static constexpr unsigned int gpioBridgeEnableMs = 20;
 // scaling factor from hwmon
@@ -78,10 +78,10 @@ ADCSensor::ADCSensor(const std::string& path,
     association = objectServer.add_interface(
         "/xyz/openbmc_project/sensors/voltage/" + name, association::interface);
     setInitialProperties(conn);
-    setupRead();
 
     // setup match
     setupPowerMatch(conn);
+    setupRead();
 }
 
 ADCSensor::~ADCSensor()
@@ -130,8 +130,42 @@ void ADCSensor::handleResponse(const boost::system::error_code& err)
 {
     if (err == boost::system::errc::bad_file_descriptor)
     {
+        updateValueInvalid(true);
         return; // we're being destroyed
     }
+
+    // Set as sensor reading invalid for power-on type sensor
+    if (readState != PowerState::always && !isPowerOn())
+    {
+        updateValueInvalid(true);
+        // updateValue(0);
+        errCount = 0;
+
+        // clear response buffer reading
+        std::istream invalidResponseStream(&readBuf);
+        std::string invalidResponse;
+        std::getline(invalidResponseStream, invalidResponse);
+        invalidResponseStream.clear();
+
+        inputDev.close();
+        int fd = open(path.c_str(), O_RDONLY);
+        if (fd <= 0)
+        {
+            return;
+        }
+        inputDev.assign(fd);
+        waitTimer.expires_from_now(boost::posix_time::milliseconds(sensorPollMs));
+        waitTimer.async_wait([&](const boost::system::error_code& ec) {
+            if (ec == boost::asio::error::operation_aborted)
+            {
+                return;
+            }
+            setupRead();
+        });
+
+        return;
+    }
+
     std::istream responseStream(&readBuf);
 
     if (!err)
@@ -152,6 +186,8 @@ void ADCSensor::handleResponse(const boost::system::error_code& err)
                 updateValue(nvalue);
             }
             errCount = 0;
+
+            updateValueInvalid(false);
         }
         catch (std::invalid_argument&)
         {
@@ -172,7 +208,8 @@ void ADCSensor::handleResponse(const boost::system::error_code& err)
 
     if (errCount >= warnAfterErrorCount)
     {
-        updateValue(0);
+        updateValueInvalid(true);
+        // updateValue(0);
     }
 
     responseStream.clear();
@@ -199,10 +236,17 @@ void ADCSensor::handleResponse(const boost::system::error_code& err)
 
 void ADCSensor::checkThresholds(void)
 {
-    if (readState == PowerState::on && !isPowerOn())
+    if (readState != PowerState::always && !isPowerOn())
     {
         return;
     }
 
-    thresholds::checkThresholdsPowerDelay(this, thresholdTimer);
+    if(readState == PowerState::always)
+    {
+        thresholds::checkThresholds(this);
+    }
+    else
+    {
+        thresholds::checkThresholdsPowerDelay(this, thresholdTimer);
+    }
 }
-- 
2.24.1

