From b484a5a9c73af2f60ddcfc74187319224cfa72ee Mon Sep 17 00:00:00 2001
From: Frederick Lee <Frederick_Lee@wiwynn.com>
Date: Tue, 9 Mar 2021 18:19:27 +0800
Subject: [PATCH] Add IPMI Platform Event Message record

---
 sensorhandler.cpp | 83 +++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 77 insertions(+), 6 deletions(-)

diff --git a/sensorhandler.cpp b/sensorhandler.cpp
index cf69027..c597280 100644
--- a/sensorhandler.cpp
+++ b/sensorhandler.cpp
@@ -1517,6 +1517,7 @@ ipmi_ret_t ipmi_sen_get_sdr(ipmi_netfn_t netfn, ipmi_cmd_t cmd,
     return IPMI_CC_RESPONSE_ERROR;
 }
 
+/*
 static bool isFromSystemChannel()
 {
     // TODO we could not figure out where the request is from based on IPMI
@@ -1524,6 +1525,7 @@ static bool isFromSystemChannel()
     // request from SMS/SMM or IPMB channel
     return true;
 }
+*/
 
 ipmi_ret_t ipmicmdPlatformEvent(ipmi_netfn_t netfn, ipmi_cmd_t cmd,
                                 ipmi_request_t request,
@@ -1531,20 +1533,25 @@ ipmi_ret_t ipmicmdPlatformEvent(ipmi_netfn_t netfn, ipmi_cmd_t cmd,
                                 ipmi_data_len_t dataLen, ipmi_context_t context)
 {
     uint16_t generatorID;
-    size_t count;
-    bool assert = true;
+    // size_t count;
+    // bool assert = true;
     std::string sensorPath;
     size_t paraLen = *dataLen;
     PlatformEventRequest* req;
     *dataLen = 0;
-
+/*
     if ((paraLen < selSystemEventSizeWith1Bytes) ||
         (paraLen > selSystemEventSizeWith3Bytes))
+*/
+    if (paraLen > selSystemEventSizeWith3Bytes)
     {
         return IPMI_CC_REQ_DATA_LEN_INVALID;
     }
 
-    if (isFromSystemChannel())
+    constexpr const uint8_t meId = 0x2C;
+    uint8_t PlatformEvent1stByte = *reinterpret_cast<uint8_t*>(request);
+    // if (isFromSystemChannel())
+    if (PlatformEvent1stByte != 0x04)
     { // first byte for SYSTEM Interface is Generator ID
         // +1 to get common struct
         req = reinterpret_cast<PlatformEventRequest*>((uint8_t*)request + 1);
@@ -1553,17 +1560,32 @@ ipmi_ret_t ipmicmdPlatformEvent(ipmi_netfn_t netfn, ipmi_cmd_t cmd,
         // Platform Event usually comes from other firmware, like BIOS.
         // Unlike BMC sensor, it does not have BMC DBUS sensor path.
         sensorPath = "System";
+
+        if (paraLen < selSystemEventSizeWith1Bytes)
+        {
+            std::cerr << "[System] Error Len:" << paraLen << "\n" << std::endl;
+            return IPMI_CC_REQ_DATA_LEN_INVALID;
+        }
     }
     else
     {
         req = reinterpret_cast<PlatformEventRequest*>(request);
         // TODO GenratorID for IPMB is combination of RqSA and RqLUN
-        generatorID = 0xff;
+        // generatorID = 0xff;
+        generatorID = meId;
         sensorPath = "IPMB";
+
+        if (paraLen < (selSystemEventSizeWith1Bytes-1))
+        {
+            std::cerr << "[IPMB] Error Len:" << paraLen << "\n" << std::endl;
+            return IPMI_CC_REQ_DATA_LEN_INVALID;
+        }
     }
+
     // Content of event data field depends on sensor class.
     // When data0 bit[5:4] is non-zero, valid data counts is 3.
     // When data0 bit[7:6] is non-zero, valid data counts is 2.
+/*
     if (((req->data[0] & byte3EnableMask) != 0 &&
          paraLen < selSystemEventSizeWith3Bytes) ||
         ((req->data[0] & byte2EnableMask) != 0 &&
@@ -1571,7 +1593,49 @@ ipmi_ret_t ipmicmdPlatformEvent(ipmi_netfn_t netfn, ipmi_cmd_t cmd,
     {
         return IPMI_CC_REQ_DATA_LEN_INVALID;
     }
+*/
+
+    // Add this request to the SEL entry
+    std::vector<uint8_t> eventData(9, 0xFF);
+    const uint8_t recordType = 0x02;
+    constexpr char const* ipmiSELService = "xyz.openbmc_project.Logging.IPMI";
+
+    eventData.at(0) = generatorID;
+    eventData.at(1) = generatorID >> 8;
+    eventData.at(2) = req->eventMessageRevision;
+    eventData.at(3) = req->sensorType;
+    eventData.at(4) = req->sensorNumber;
+    eventData.at(5) = req->eventDirectionType;
+    eventData.at(6) = req->data[0];
+    eventData.at(7) = 0xFF;
+    eventData.at(8) = 0xFF;
+
+    if (generatorID == meId)
+    {
+        if (paraLen == (selSystemEventSizeWith2Bytes-1))
+        {
+            eventData.at(7) = req->data[1];
+        }
+        else if (paraLen == (selSystemEventSizeWith3Bytes-1))
+        {
+            eventData.at(7) = req->data[1];
+            eventData.at(8) = req->data[2];
+        }
+    }
+    else
+    {
+        if (paraLen == selSystemEventSizeWith2Bytes)
+        {
+            eventData.at(7) = req->data[1];
+        }
+        else if (paraLen == selSystemEventSizeWith3Bytes)
+        {
+            eventData.at(7) = req->data[1];
+            eventData.at(8) = req->data[2];
+        }
+    }
 
+/*
     // Count bytes of Event Data
     if ((req->data[0] & byte3EnableMask) != 0)
     {
@@ -1585,16 +1649,23 @@ ipmi_ret_t ipmicmdPlatformEvent(ipmi_netfn_t netfn, ipmi_cmd_t cmd,
     {
         count = 1;
     }
+
     assert = req->eventDirectionType & directionMask ? false : true;
     std::vector<uint8_t> eventData(req->data, req->data + count);
-
+*/
     sdbusplus::bus::bus dbus(bus);
+    sdbusplus::message::message writeSEL = dbus.new_method_call(
+        ipmiSELService, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAddOem");
+    writeSEL.append(ipmiSELAddMessage, eventData, recordType);
+/*
     std::string service =
         ipmi::getService(dbus, ipmiSELAddInterface, ipmiSELPath);
     sdbusplus::message::message writeSEL = dbus.new_method_call(
         service.c_str(), ipmiSELPath, ipmiSELAddInterface, "IpmiSelAdd");
     writeSEL.append(ipmiSELAddMessage, sensorPath, eventData, assert,
                     generatorID);
+*/
+
     try
     {
         dbus.call(writeSEL);
-- 
2.17.1

