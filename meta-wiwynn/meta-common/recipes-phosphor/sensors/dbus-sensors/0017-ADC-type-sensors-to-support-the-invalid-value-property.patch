From 9397713ac30a85ddd4b122f0e4f14ba9c9cf8187 Mon Sep 17 00:00:00 2001
From: Frederick Lee <Frederick_Lee@wiwynn.com>
Date: Mon, 9 Dec 2019 20:45:15 +0800
Subject: [PATCH] ADC-type sensors to support the invalid value property

---
 src/ADCSensor.cpp | 53 ++++++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 48 insertions(+), 5 deletions(-)

diff --git a/src/ADCSensor.cpp b/src/ADCSensor.cpp
index 2816ae7..904f57a 100644
--- a/src/ADCSensor.cpp
+++ b/src/ADCSensor.cpp
@@ -78,10 +78,9 @@ ADCSensor::ADCSensor(const std::string& path,
         "/xyz/openbmc_project/sensors/voltage/" + name,
         "org.openbmc.Associations");
     setInitialProperties(conn);
-    setupRead();
-
     // setup match
     setupPowerMatch(conn);
+    setupRead();
 }
 
 ADCSensor::~ADCSensor()
@@ -130,8 +129,42 @@ void ADCSensor::handleResponse(const boost::system::error_code& err)
 {
     if (err == boost::system::errc::bad_file_descriptor)
     {
+        updateValueInvalid(true);
         return; // we're being destroyed
     }
+
+    // Set as sensor reading invalid for power-on type sensor
+    if (readState != PowerState::always && !isPowerOn())
+    {
+        updateValueInvalid(true);
+        // updateValue(0);
+        errCount = 0;
+
+        // clear response buffer reading
+        std::istream invalidResponseStream(&readBuf);
+        std::string invalidResponse;
+        std::getline(invalidResponseStream, invalidResponse);
+        invalidResponseStream.clear();
+
+        inputDev.close();
+        int fd = open(path.c_str(), O_RDONLY);
+        if (fd <= 0)
+        {
+            return;
+        }
+        inputDev.assign(fd);
+        waitTimer.expires_from_now(boost::posix_time::milliseconds(sensorPollMs));
+        waitTimer.async_wait([&](const boost::system::error_code& ec) {
+            if (ec == boost::asio::error::operation_aborted)
+            {
+                return;
+            }
+            setupRead();
+        });
+
+        return;
+    }
+
     std::istream responseStream(&readBuf);
 
     if (!err)
@@ -152,6 +185,8 @@ void ADCSensor::handleResponse(const boost::system::error_code& err)
                 updateValue(nvalue);
             }
             errCount = 0;
+
+            updateValueInvalid(false);
         }
         catch (std::invalid_argument&)
         {
@@ -172,7 +207,8 @@ void ADCSensor::handleResponse(const boost::system::error_code& err)
 
     if (errCount >= warnAfterErrorCount)
     {
-        updateValue(0);
+        updateValueInvalid(true);
+        // updateValue(0);
     }
 
     responseStream.clear();
@@ -199,10 +235,17 @@ void ADCSensor::handleResponse(const boost::system::error_code& err)
 
 void ADCSensor::checkThresholds(void)
 {
-    if (readState == PowerState::on && !isPowerOn())
+    if (readState != PowerState::always && !isPowerOn())
     {
         return;
     }
 
-    thresholds::checkThresholdsPowerDelay(this, thresholdTimer);
+    if(readState == PowerState::always)
+    {
+        thresholds::checkThresholds(this);
+    }
+    else
+    {
+        thresholds::checkThresholdsPowerDelay(this, thresholdTimer);
+    }
 }
-- 
2.22.0

