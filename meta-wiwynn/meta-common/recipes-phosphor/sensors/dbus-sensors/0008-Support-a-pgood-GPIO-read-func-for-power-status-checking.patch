From 4c5032afaddd7ff8a0f564ff69cd12461f4ac05b Mon Sep 17 00:00:00 2001
From: Frederick Lee <Frederick_Lee@wiwynn.com>
Date: Mon, 16 Dec 2019 15:46:17 +0800
Subject: [PATCH] Support a pgood GPIO read function for power status checking

---
 CMakeLists.txt    |  2 +-
 include/Utils.hpp |  2 ++
 src/Utils.cpp     | 92 +++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 95 insertions(+), 1 deletion(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 0d29f01..fd8992b 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -81,7 +81,7 @@ set (PSU_SRC_FILES src/Utils.cpp src/PSUSensor.cpp src/Thresholds.cpp
      src/PwmSensor.cpp src/PSUEvent.cpp)
 
 set (EXTERNAL_PACKAGES Boost sdbusplus-project nlohmann-json)
-set (SENSOR_LINK_LIBS -lsystemd -lobmci2c -lobmcmisc stdc++fs sdbusplus)
+set (SENSOR_LINK_LIBS -lsystemd -lobmci2c -lobmcmisc -lobmcgpio stdc++fs sdbusplus)
 
 if (NOT YOCTO)
     option (ENABLE_TEST "Enable Google Test" OFF)
diff --git a/include/Utils.hpp b/include/Utils.hpp
index 44e7e2e..3afacd5 100644
--- a/include/Utils.hpp
+++ b/include/Utils.hpp
@@ -53,6 +53,8 @@ bool findFiles(const std::filesystem::path dirPath,
                unsigned int symlinkDepth = 1);
 bool isPowerOn(void);
 bool hasBiosPost(void);
+bool isPowerGood(void);
+bool getGpioNumber(const std::string& gpioName, uint16_t& gpioNumber);
 void setupPowerMatch(const std::shared_ptr<sdbusplus::asio::connection>& conn);
 bool getSensorConfiguration(
     const std::string& type,
diff --git a/src/Utils.cpp b/src/Utils.cpp
index 44a6bae..48921cc 100644
--- a/src/Utils.cpp
+++ b/src/Utils.cpp
@@ -30,6 +30,10 @@
 #include <utility>
 #include <variant>
 #include <vector>
+#include <openbmc/libobmcgpio.h>
+#include <systemd/sd-journal.h>
+#include <nlohmann/json.hpp>
+#include <gpioplus/utility/aspeed.hpp>
 
 namespace fs = std::filesystem;
 
@@ -39,6 +43,11 @@ static bool biosHasPost = false;
 static std::unique_ptr<sdbusplus::bus::match::match> powerMatch = nullptr;
 static std::unique_ptr<sdbusplus::bus::match::match> postMatch = nullptr;
 
+static constexpr auto gpioDefs = "/etc/default/obmc/gpio/gpio_defs.json";
+static uint16_t pgoodGpioNum = std::numeric_limits<uint16_t>::quiet_NaN();
+static bool isPgoodGpioNumValid = false;
+static uint16_t gpioChipId = 0;
+
 bool getSensorConfiguration(
     const std::string& type,
     const std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
@@ -136,6 +145,78 @@ bool hasBiosPost(void)
     return biosHasPost;
 }
 
+bool isPowerGood(void)
+{
+    bool powerStatusGood = false;
+
+    if(!isPgoodGpioNumValid)
+    {
+        uint16_t gpioNum;
+        if(!getGpioNumber("PGOOD", gpioNum))
+        {
+            std::cerr<<"No pgood GPIO found\n";
+            return powerStatusGood;
+        }
+
+        pgoodGpioNum = gpioNum;
+        isPgoodGpioNumValid = true;
+    }
+
+    uint8_t state = 0;
+    int rc = gpio_read_value(gpioChipId, pgoodGpioNum, &state);
+    if(0 != rc)
+    {
+        std::cerr<<"Failed to read pgood\n";
+        return powerStatusGood;
+    }
+
+    if(1 == state)
+    {
+        powerStatusGood = true;
+    }
+
+    return powerStatusGood;
+}
+
+bool getGpioNumber(const std::string& gpioName, uint16_t& gpioNumber)
+{
+    std::ifstream gpios(gpioDefs);
+    if(!gpios)
+    {
+        std::cerr << "failed to open gpio defs file: " << gpioDefs <<"\n";
+        return false;
+    }
+
+    try
+    {
+        auto json = nlohmann::json::parse(gpios, nullptr, true);
+        auto defs = json["gpio_definitions"];
+
+        auto gpio =
+            std::find_if(defs.begin(), defs.end(), [&gpioName](const auto g) {
+                return gpioName == g["name"];
+            });
+
+        if (gpio != defs.end())
+        {
+            std::string gpioPin = (*gpio)["pin"];
+            gpioNumber = static_cast<uint16_t>
+                        (gpioplus::utility::aspeed::nameToOffset(gpioPin));
+            gpios.close();
+
+            return true;
+        }
+    }
+    catch (std::exception& e)
+    {
+        std::cerr<<"Error parsing gpio json\n";
+    }
+
+    gpios.close();
+
+    return false;
+}
+
 void setupPowerMatch(const std::shared_ptr<sdbusplus::asio::connection>& conn)
 {
     static boost::asio::steady_timer timer(conn->get_io_context());
@@ -230,6 +311,17 @@ void setupPowerMatch(const std::shared_ptr<sdbusplus::asio::connection>& conn)
         },
         post::busname, post::path, properties::interface, properties::get,
         post::interface, post::property);
+
+    // Get pgood GPIO number
+    if(!isPgoodGpioNumValid)
+    {
+        uint16_t gpioNum;
+        if(getGpioNumber("PGOOD", gpioNum))
+        {
+            pgoodGpioNum = gpioNum;
+            isPgoodGpioNumValid = true;
+        }
+    }
 }
 
 // replaces limits if MinReading and MaxReading are found.
-- 
2.24.1

