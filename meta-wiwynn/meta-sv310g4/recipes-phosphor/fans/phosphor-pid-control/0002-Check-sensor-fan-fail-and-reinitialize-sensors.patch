From 70a21472a1b163cb4a1e57da175aa04440d8a550 Mon Sep 17 00:00:00 2001
From: Eilin <eilin_li@wiwynn.com>
Date: Mon, 22 Feb 2021 11:40:37 +0800
Subject: [PATCH] Check sensor fan fail and reinitialize sensors

---
 conf.hpp                   |  39 +++-
 configure.ac               |   6 +
 dbus/dbusconfiguration.cpp |   4 +-
 dbus/dbushelper.hpp        |   4 +
 dbus/dbuspassive.cpp       |  17 +-
 dbus/dbuspassive.hpp       |   4 +-
 dbus/dbusutil.hpp          |  17 ++
 main.cpp                   |  32 +++
 pid/builder.cpp            |  27 ++-
 pid/buildjson.cpp          | 164 +++++++++++++-
 pid/fancontroller.cpp      |  27 ++-
 pid/pidcontroller.cpp      |   6 +
 pid/pidloop.cpp            | 156 +++++++------
 pid/pidloop.hpp            |   3 +-
 pid/stepwisecontroller.cpp |  13 +-
 pid/thermalcontroller.cpp  |   7 -
 pid/zone.cpp               | 452 ++++++++++++++++++++++++++++++++++---
 pid/zone.hpp               |  38 +++-
 pid/zone_interface.hpp     |  21 +-
 sensors/builder.cpp        |  22 +-
 sensors/buildjson.cpp      |  28 +++
 sensors/host.cpp           |  13 +-
 sensors/host.hpp           |  13 +-
 sensors/manager.hpp        |   4 +-
 sensors/pluggable.hpp      |  17 +-
 sensors/sensor.hpp         |  30 ++-
 sysfs/util.cpp             | 102 ++++++++-
 util.cpp                   |   2 +-
 util.hpp                   |  14 ++
 29 files changed, 1109 insertions(+), 173 deletions(-)

diff --git a/conf.hpp b/conf.hpp
index 89d5df1..d5288e7 100644
--- a/conf.hpp
+++ b/conf.hpp
@@ -22,6 +22,10 @@ struct SensorConfig
     /* Can be a sensor path or a dbus path. */
     std::string readPath;
     std::string writePath;
+    /* Tjmax file path, read from PECI driver to adjust temperature values */
+    std::string tjMaxPath;
+    /* Scale tjmax value which read from PECI driver */
+    double tjMaxScale;
     /* min/max values for writing a percentage or error checking. */
     int64_t min;
     int64_t max;
@@ -41,6 +45,28 @@ struct ControllerInfo
     ec::StepwiseInfo stepwiseInfo;
 };
 
+/*
+ * Sturcture for specialized fan and sensor failsafe percent.
+ */
+struct FailsafeProfile
+{
+    uint64_t fanFailCount;                // fan fail count.
+    std::vector<std::string> sensorNames; // the failed sensor name.
+    std::string outputType;               // linear or value.
+    std::vector<std::string> inputs;      // linear reference sensors.
+    std::vector<double> reading;          // sensor reading for linear.
+    std::vector<double> output;           // corresponding output for linear.
+    double failsafePercent;               // failsafe percent value.
+};
+
+struct FailsafeSetting
+{
+    // Customize fan failsafe percentage.
+    std::vector<struct FailsafeProfile> fanFailsafeProfiles;
+    // Customize sensor failsafe percentage.
+    std::vector<struct FailsafeProfile> sensorFailsafeProfiles;
+};
+
 /*
  * General zone structure used for configuration.  A zone is a list of PIDs
  * and a set of configuration settings.  This structure gets filled out with
@@ -51,8 +77,17 @@ struct ZoneConfig
     /* The minimum set-point value we would ever want (typically in RPM) */
     double minThermalOutput;
 
-    /* If the sensors are in fail-safe mode, this is the percentage to use. */
-    double failsafePercent;
+    /* Define failsafe percentage if fans or sensors are failed. */
+    struct FailsafeSetting failsafeSetting;
+
+    /* The time interval every cycle. 0.1 seconds by default */
+    uint64_t cycleTimeBase = 100; // milliseconds
+
+    /* The interval of checking fan failures. 10 seconds by default */
+    uint64_t checkFanFailuresTime = 10000; // milliseconds
+
+    /* The interval of updating thermals. 1 second by default */
+    uint64_t updateThermalsTime = 1000; // milliseconds
 };
 
 using PIDConf = std::map<std::string, ControllerInfo>;
diff --git a/configure.ac b/configure.ac
index 82d7d8a..7ffabbb 100644
--- a/configure.ac
+++ b/configure.ac
@@ -204,6 +204,12 @@ AC_ARG_ENABLE([configure-dbus],
     )
 )
 
+AC_ARG_VAR(DEFAULT_PWM,
+    [The default pwm value (percertage).])
+AS_IF([test "x$DEFAULT_PWM" == "x"], [DEFAULT_PWM=100])
+AC_DEFINE_UNQUOTED([DEFAULT_PWM], [$DEFAULT_PWM],
+                   [The default pwm value (percertage).])
+
 AC_ARG_VAR(SYSTEMD_TARGET, "Target for starting this service")
 AS_IF([test "x$SYSTEMD_TARGET" == "x"], [SYSTEMD_TARGET="multi-user.target"])
 
diff --git a/dbus/dbusconfiguration.cpp b/dbus/dbusconfiguration.cpp
index 61924cc..eecd7d2 100644
--- a/dbus/dbusconfiguration.cpp
+++ b/dbus/dbusconfiguration.cpp
@@ -569,8 +569,8 @@ bool init(sdbusplus::bus::bus& bus, boost::asio::steady_timer& timer,
 
             details.minThermalOutput = std::visit(VariantToDoubleVisitor(),
                                                   zone.at("MinThermalOutput"));
-            details.failsafePercent = std::visit(VariantToDoubleVisitor(),
-                                                 zone.at("FailSafePercent"));
+            // details.failsafePercent = std::visit(VariantToDoubleVisitor(),
+            //                                      zone.at("FailSafePercent"));
         }
         auto findBase = configuration.second.find(pidConfigurationInterface);
         // loop through all the PID configurations and fill out a sensor config
diff --git a/dbus/dbushelper.hpp b/dbus/dbushelper.hpp
index 81a7238..8bd83d5 100644
--- a/dbus/dbushelper.hpp
+++ b/dbus/dbushelper.hpp
@@ -18,6 +18,10 @@ class DbusHelper : public DbusHelperInterface
     static constexpr char propertiesintf[] = "org.freedesktop.DBus.Properties";
     static constexpr char criticalThreshInf[] =
         "xyz.openbmc_project.Sensor.Threshold.Critical";
+    static constexpr char availableIntf[] =
+        "xyz.openbmc_project.State.Decorator.Availability";
+    static constexpr char functionalIntf[] =
+        "xyz.openbmc_project.State.Decorator.OperationalStatus";
 
     explicit DbusHelper(sdbusplus::bus::bus bus) : _bus(std::move(bus))
     {}
diff --git a/dbus/dbuspassive.cpp b/dbus/dbuspassive.cpp
index 0c73db2..3286e46 100644
--- a/dbus/dbuspassive.cpp
+++ b/dbus/dbuspassive.cpp
@@ -146,7 +146,7 @@ bool DbusPassive::getFailed(void) const
         return true;
     }
 
-    return _failed || !_functional;
+    return !_functional || !_available;
 }
 
 void DbusPassive::setFailed(bool value)
@@ -159,6 +159,11 @@ void DbusPassive::setFunctional(bool value)
     _functional = value;
 }
 
+void DbusPassive::setAvailable(bool value)
+{
+    _available = value;
+}
+
 int64_t DbusPassive::getScale(void)
 {
     return _scale;
@@ -278,6 +283,16 @@ int handleSensorValue(sdbusplus::message::message& msg, DbusPassive* owner)
         bool asserted = std::get<bool>(functional->second);
         owner->setFunctional(asserted);
     }
+    else if (msgSensor == "xyz.openbmc_project.State.Decorator.Availability")
+    {
+        auto available = msgData.find("Available");
+        if (available == msgData.end())
+        {
+            return 0;
+        }
+        bool asserted = std::get<bool>(available->second);
+        owner->setAvailable(asserted);
+    }
 
     return 0;
 }
diff --git a/dbus/dbuspassive.hpp b/dbus/dbuspassive.hpp
index 9065a29..54645c5 100644
--- a/dbus/dbuspassive.hpp
+++ b/dbus/dbuspassive.hpp
@@ -61,7 +61,7 @@ class DbusPassive : public ReadInterface
 
     void setFailed(bool value);
     void setFunctional(bool value);
-
+    void setAvailable(bool value);
     int64_t getScale(void);
     std::string getID(void);
     double getMax(void);
@@ -79,7 +79,7 @@ class DbusPassive : public ReadInterface
     double _min = 0;
     bool _failed = false;
     bool _functional = true;
-
+    bool _available = true;
     bool _typeMargin = false;
     bool _badReading = false;
     bool _marginHot = false;
diff --git a/dbus/dbusutil.hpp b/dbus/dbusutil.hpp
index 7faf4fc..fec9d25 100644
--- a/dbus/dbusutil.hpp
+++ b/dbus/dbusutil.hpp
@@ -28,6 +28,23 @@ struct VariantToDoubleVisitor
     }
 };
 
+struct VariantToBoolVisitor
+{
+    template <typename T>
+    std::enable_if_t<std::is_arithmetic<T>::value, bool>
+        operator()(const T& t) const
+    {
+        return static_cast<bool>(t);
+    }
+
+    template <typename T>
+    std::enable_if_t<!std::is_arithmetic<T>::value, bool>
+        operator()(const T& t) const
+    {
+        throw std::invalid_argument("Cannot translate type to bool");
+    }
+};
+
 std::string getSensorPath(const std::string& type, const std::string& id);
 std::string getMatch(const std::string& type, const std::string& id);
 void scaleSensorReading(const double min, const double max, double& value);
diff --git a/main.cpp b/main.cpp
index 6417551..00cc948 100644
--- a/main.cpp
+++ b/main.cpp
@@ -154,6 +154,38 @@ void restartControlLoops()
     }
 
     mgmr = buildSensors(sensorConfig, passiveBus, hostBus);
+
+    // If tjMax is defined, adjust setpoint value and stepwise reading point.
+    for (auto& zone : zoneConfig)
+    {
+        conf::PIDConf* pids = &zone.second;
+        // For all profiles
+        for (auto& pid : *pids)
+        {
+            struct conf::ControllerInfo* info = &pid.second;
+            // To avoid adjust values twice.
+            bool tjMaxAdjusted = false;
+            for (size_t i = 0; i < info->inputs.size(); ++i)
+            {
+                auto sensor = mgmr.getSensor(info->inputs[i]);
+                double tjMax = sensor->getTjMax();
+                if ((tjMax != 0) && (tjMaxAdjusted == false))
+                {
+                    tjMaxAdjusted = true;
+                    info->setpoint = tjMax + info->setpoint;
+
+                    if ((info->type == "stepwise") || (info->type == "linear"))
+                    {
+                        for (auto& point : info->stepwiseInfo.reading)
+                        {
+                            point = tjMax + point;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
     zones = buildZones(zoneConfig, zoneDetailsConfig, mgmr, modeControlBus);
 
     if (0 == zones.size())
diff --git a/pid/builder.cpp b/pid/builder.cpp
index 450be75..a80ba32 100644
--- a/pid/builder.cpp
+++ b/pid/builder.cpp
@@ -69,7 +69,9 @@ std::unordered_map<int64_t, std::shared_ptr<ZoneInterface>>
 
         auto zone = std::make_shared<DbusPidZone>(
             zoneId, zoneConf->second.minThermalOutput,
-            zoneConf->second.failsafePercent, mgr, modeControlBus,
+            zoneConf->second.failsafeSetting, zoneConf->second.cycleTimeBase,
+            zoneConf->second.checkFanFailuresTime,
+            zoneConf->second.updateThermalsTime, mgr, modeControlBus,
             getControlPath(zoneId).c_str(), deferSignals);
 
         std::cerr << "Zone Id: " << zone->getZoneID() << "\n";
@@ -108,6 +110,17 @@ std::unordered_map<int64_t, std::shared_ptr<ZoneInterface>>
                     zone.get(), name, inputs, info.setpoint, info.pidInfo,
                     getThermalType(info.type));
 
+                /*
+                 * Keep pid control operating when creating thermal pid failed
+                 * and skipping this failed thermal pid.
+                 */
+                if (pid == nullptr)
+                {
+                    std::cerr << "Failed to create thermal pid. Skip " << name
+                              << " of type: " << info.type << "\n";
+                    continue;
+                }
+
                 zone->addThermalPID(std::move(pid));
             }
             else if (info.type == "stepwise" || info.type == "linear")
@@ -119,6 +132,18 @@ std::unordered_map<int64_t, std::shared_ptr<ZoneInterface>>
                 }
                 auto stepwise = StepwiseController::createStepwiseController(
                     zone.get(), name, info.type, inputs, info.stepwiseInfo);
+                
+                /*
+                 * Keep pid control operating when creating thermal pid failed
+                 * and skipping this failed stepwise.
+                 */
+                if (stepwise == nullptr)
+                {
+                    std::cerr << "Failed to create stepwise controller. Skip "
+                              << name << " of type: " << info.type << "\n";
+                    continue;
+                }
+
                 zone->addThermalPID(std::move(stepwise));
             }
 
diff --git a/pid/buildjson.cpp b/pid/buildjson.cpp
index fb2b986..b2ff935 100644
--- a/pid/buildjson.cpp
+++ b/pid/buildjson.cpp
@@ -20,6 +20,7 @@
 
 #include <nlohmann/json.hpp>
 
+#include <iostream>
 #include <map>
 #include <tuple>
 
@@ -128,6 +129,129 @@ void from_json(const json& j, conf::ControllerInfo& c)
 }
 } // namespace conf
 
+void parsingFailsafeProfiles(
+    const json& profiles,
+    std::vector<struct conf::FailsafeProfile>& inputProfiles)
+{
+    for (auto& profile : profiles)
+    {
+        struct conf::FailsafeProfile tmp;
+
+        auto fanFailCountFind = profile.find("fanFailCount");
+        auto sensorNamesFind = profile.find("sensorNames");
+        if (fanFailCountFind != profile.end())
+        {
+            fanFailCountFind->get_to(tmp.fanFailCount);
+        }
+        else if (sensorNamesFind != profile.end())
+        {
+            sensorNamesFind->get_to(tmp.sensorNames);
+        }
+        else
+        {
+            std::cerr << "Missing fanFailCount or sensorNames"
+                      << " in failsafe profiles\n";
+            continue;
+        }
+
+        auto outputTypeFind = profile.find("outputType");
+        if (outputTypeFind != profile.end())
+        {
+            outputTypeFind->get_to(tmp.outputType);
+        }
+        else
+        {
+            std::cerr << "Missing outputType in failsafe profiles\n";
+            continue;
+        }
+
+        if ((*outputTypeFind == "linear") || (*outputTypeFind == "stepwise"))
+        {
+            auto inputsFind = profile.find("inputs");
+            if (inputsFind != profile.end())
+            {
+                inputsFind->get_to(tmp.inputs);
+            }
+            else
+            {
+                std::cerr << "Missing inputs in failsafe profiles\n";
+                continue;
+            }
+
+            auto readingFind = profile.find("reading");
+            if (readingFind != profile.end())
+            {
+                for (size_t i = 0;; ++i)
+                {
+                    auto valueFind = readingFind->find(std::to_string(i));
+                    if (valueFind != readingFind->end())
+                    {
+                        tmp.reading.emplace_back(std::move(*valueFind));
+                    }
+                    else
+                    {
+                        break;
+                    }
+                }
+            }
+            else
+            {
+                std::cerr << "Missing reading in failsafe profiles\n";
+                continue;
+            }
+
+            auto outputFind = profile.find("output");
+            if (outputFind != profile.end())
+            {
+                for (size_t i = 0;; ++i)
+                {
+                    auto valueFind = outputFind->find(std::to_string(i));
+                    if (valueFind != outputFind->end())
+                    {
+                        tmp.output.emplace_back(std::move(*valueFind));
+                    }
+                    else
+                    {
+                        break;
+                    }
+                }
+            }
+            else
+            {
+                std::cerr << "Missing output in failsafe profiles\n";
+                continue;
+            }
+
+            if (tmp.reading.size() != tmp.output.size())
+            {
+                std::cerr << "Output size doesn't match reading size"
+                          << "failsafe profiles\n";
+                continue;
+            }
+        }
+        else if (*outputTypeFind == "value")
+        {
+            auto failsafePercentFind = profile.find("failsafePercent");
+            if (failsafePercentFind != profile.end())
+            {
+                tmp.failsafePercent = *failsafePercentFind;
+            }
+            else
+            {
+                std::cerr << "Missing failsafePercent in failsafe profiles\n";
+                continue;
+            }
+        }
+        else
+        {
+            std::cerr << "Unknown outputType in failsafe profiles\n";
+            continue;
+        }
+
+        inputProfiles.emplace_back(std::move(tmp));
+    }
+}
+
 std::pair<std::map<int64_t, conf::PIDConf>, std::map<int64_t, conf::ZoneConfig>>
     buildPIDsFromJson(const json& data)
 {
@@ -147,7 +271,45 @@ std::pair<std::map<int64_t, conf::PIDConf>, std::map<int64_t, conf::ZoneConfig>>
         /* TODO: using at() throws a specific exception we can catch */
         id = zone["id"];
         thisZoneConfig.minThermalOutput = zone["minThermalOutput"];
-        thisZoneConfig.failsafePercent = zone["failsafePercent"];
+        auto fanFailsafeProfilesFind = zone.find("fanFailsafeProfiles");
+        if (fanFailsafeProfilesFind != zone.end())
+        {
+            parsingFailsafeProfiles(
+                *fanFailsafeProfilesFind,
+                thisZoneConfig.failsafeSetting.fanFailsafeProfiles);
+
+            // Sort profile's order with fanFailCount, the largest is first.
+            std::sort(
+                thisZoneConfig.failsafeSetting.fanFailsafeProfiles.begin(),
+                thisZoneConfig.failsafeSetting.fanFailsafeProfiles.end(),
+                [](const struct conf::FailsafeProfile& a,
+                   const struct conf::FailsafeProfile& b) -> bool {
+                    return a.fanFailCount > b.fanFailCount;
+                });
+        }
+        auto sensorFailsafeProfilesFind = zone.find("sensorFailsafeProfiles");
+        if (sensorFailsafeProfilesFind != zone.end())
+        {
+            parsingFailsafeProfiles(
+                *sensorFailsafeProfilesFind,
+                thisZoneConfig.failsafeSetting.sensorFailsafeProfiles);
+        }
+
+        auto timeBaseFind = zone.find("cycleTimeBase");
+        if (timeBaseFind != zone.end())
+        {
+            thisZoneConfig.cycleTimeBase = *timeBaseFind;
+        }
+        auto timeCheckFanFailuresFind = zone.find("checkFanFailuresTime");
+        if (timeCheckFanFailuresFind != zone.end())
+        {
+            thisZoneConfig.checkFanFailuresTime = *timeCheckFanFailuresFind;
+        }
+        auto timeUpdateThermalsFind = zone.find("updateThermalsTime");
+        if (timeUpdateThermalsFind != zone.end())
+        {
+            thisZoneConfig.updateThermalsTime = *timeUpdateThermalsFind;
+        }
 
         auto pids = zone["pids"];
         for (const auto& pid : pids)
diff --git a/pid/fancontroller.cpp b/pid/fancontroller.cpp
index 3d44284..3791966 100644
--- a/pid/fancontroller.cpp
+++ b/pid/fancontroller.cpp
@@ -129,16 +129,18 @@ void FanController::outputProc(double value)
     /* If doing tuning, don't go into failsafe mode. */
     if (!tuningEnabled)
     {
-        if (_owner->getFailSafeMode())
+        double failsafePercent = 0.0;
+        if (_owner->getFailSafe(failsafePercent))
         {
             /* In case it's being set to 100% */
-            if (percent < _owner->getFailSafePercent())
+            if (percent < failsafePercent)
             {
-                percent = _owner->getFailSafePercent();
+                percent = failsafePercent;
             }
             if ((failsafePrint == false) || (debugModeEnabled == true))
             {
-                std::cerr << "Fans output failsafe pwm: " << percent << "\n";
+                std::cerr << "Zone " << _owner->getZoneID()
+                          << " fans output failsafe pwm: " << percent << "\n";
                 failsafePrint = true;
             }
         }
@@ -147,11 +149,26 @@ void FanController::outputProc(double value)
             failsafePrint = false;
             if (debugModeEnabled)
             {
-                std::cerr << "Fans output pwm: " << percent << "\n";
+                std::cerr << "Zone " << _owner->getZoneID()
+                          << " fans output pwm: " << percent << "\n";
             }
          }
     }
 
+    /* If current output pwm is equal to last output pwm
+     * Set fan failure checking flag to true
+     * Going to do fan failure checking process
+     */
+    if (percent == getLastOutput())
+    {
+        _owner->setCheckFanFailuresFlag(true);
+    }
+    else
+    {
+        _owner->setCheckFanFailuresFlag(false);
+        setLastOutput(percent);
+    }
+
     // value and kFanFailSafeDutyCycle are 10 for 10% so let's fix that.
     percent /= 100;
 
diff --git a/pid/pidcontroller.cpp b/pid/pidcontroller.cpp
index c2478e8..2e81bc1 100644
--- a/pid/pidcontroller.cpp
+++ b/pid/pidcontroller.cpp
@@ -42,6 +42,12 @@ void PIDController::process(void)
     // Get input value
     input = inputProc();
 
+    // There is no inputs pid can use in this controller, skip it.
+    if (input == std::numeric_limits<double>::lowest())
+    {
+        return;
+    }
+
     // Initialize if not set yet
     if (std::isnan(lastInput))
     {
diff --git a/pid/pidloop.cpp b/pid/pidloop.cpp
index 711ba2f..59fba2f 100644
--- a/pid/pidloop.cpp
+++ b/pid/pidloop.cpp
@@ -48,7 +48,8 @@ static void processThermals(std::shared_ptr<ZoneInterface> zone)
 
 void pidControlLoop(std::shared_ptr<ZoneInterface> zone,
                     std::shared_ptr<boost::asio::steady_timer> timer,
-                    bool first, int ms100cnt)
+                    bool first, uint64_t ms100cnt,
+                    uint64_t checkFanFailuresCount)
 {
     if (first)
     {
@@ -61,72 +62,93 @@ void pidControlLoop(std::shared_ptr<ZoneInterface> zone,
         processThermals(zone);
     }
 
-    timer->expires_after(std::chrono::milliseconds(100));
-    timer->async_wait(
-        [zone, timer, ms100cnt](const boost::system::error_code& ec) mutable {
-            if (ec == boost::asio::error::operation_aborted)
-            {
-                return; // timer being canceled, stop loop
-            }
-
-            /*
-             * This should sleep on the conditional wait for the listen thread
-             * to tell us it's in sync.  But then we also need a timeout option
-             * in case phosphor-hwmon is down, we can go into some weird failure
-             * more.
-             *
-             * Another approach would be to start all sensors in worst-case
-             * values, and fail-safe mode and then clear out of fail-safe mode
-             * once we start getting values.  Which I think it is a solid
-             * approach.
-             *
-             * For now this runs before it necessarily has any sensor values.
-             * For the host sensors they start out in fail-safe mode.  For the
-             * fans, they start out as 0 as input and then are adjusted once
-             * they have values.
-             *
-             * If a fan has failed, it's value will be whatever we're told or
-             * however we retrieve it.  This program disregards fan values of 0,
-             * so any code providing a fan speed can set to 0 on failure and
-             * that fan value will be effectively ignored.  The PID algorithm
-             * will be unhappy but nothing bad will happen.
-             *
-             * TODO(venture): If the fan value is 0 should that loop just be
-             * skipped? Right now, a 0 value is ignored in
-             * FanController::inputProc()
-             */
-
-            // Check if we should just go back to sleep.
-            if (zone->getManualMode())
-            {
-                pidControlLoop(zone, timer, false, ms100cnt);
-                return;
-            }
-
-            // Get the latest fan speeds.
-            zone->updateFanTelemetry();
-
-            if (10 <= ms100cnt)
-            {
-                ms100cnt = 0;
-
-                processThermals(zone);
-            }
-
-            // Run the fan PIDs every iteration.
-            zone->processFans();
-
-            if (loggingEnabled)
-            {
-                std::ostringstream out;
-                out << "," << zone->getFailSafeMode() << std::endl;
-                zone->writeLog(out.str());
-            }
-
-            ms100cnt += 1;
-
-            pidControlLoop(zone, timer, false, ms100cnt);
-        });
+    // Cycle time is 100 milliseconds by default.
+    timer->expires_after(std::chrono::milliseconds(zone->getCycleTimeBase()));
+    timer->async_wait([zone, timer, ms100cnt, checkFanFailuresCount](
+                          const boost::system::error_code& ec) mutable {
+        if (ec == boost::asio::error::operation_aborted)
+        {
+            return; // timer being canceled, stop loop
+        }
+
+        /*
+         * This should sleep on the conditional wait for the listen thread
+         * to tell us it's in sync.  But then we also need a timeout option
+         * in case phosphor-hwmon is down, we can go into some weird failure
+         * more.
+         *
+         * Another approach would be to start all sensors in worst-case
+         * values, and fail-safe mode and then clear out of fail-safe mode
+         * once we start getting values.  Which I think it is a solid
+         * approach.
+         *
+         * For now this runs before it necessarily has any sensor values.
+         * For the host sensors they start out in fail-safe mode.  For the
+         * fans, they start out as 0 as input and then are adjusted once
+         * they have values.
+         *
+         * If a fan has failed, it's value will be whatever we're told or
+         * however we retrieve it.  This program disregards fan values of 0,
+         * so any code providing a fan speed can set to 0 on failure and
+         * that fan value will be effectively ignored.  The PID algorithm
+         * will be unhappy but nothing bad will happen.
+         *
+         * TODO(venture): If the fan value is 0 should that loop just be
+         * skipped? Right now, a 0 value is ignored in
+         * FanController::inputProc()
+         */
+
+        // Check if we should just go back to sleep.
+        if (zone->getManualMode())
+        {
+            pidControlLoop(zone, timer, false, ms100cnt, checkFanFailuresCount);
+            return;
+        }
+
+        // Get the latest fan speeds.
+        zone->updateFanTelemetry();
+
+        // Check fail failures every 10 seconds by default.
+        if (zone->getCheckFanFailuresCycle() != 0 &&
+            zone->getCheckFanFailuresCycle() <= checkFanFailuresCount)
+        {
+            checkFanFailuresCount = 0;
+
+            zone->checkFanFailures();
+        }
+
+        // Update Thermals value every 1 second by default.
+        if (zone->getUpdateThermalsCycle() <= ms100cnt)
+        {
+            ms100cnt = 0;
+
+            processThermals(zone);
+        }
+
+        // Run the fan PIDs every iteration.
+        zone->processFans();
+
+        if (loggingEnabled)
+        {
+            double failsafePercent = 0.0;
+            std::ostringstream out;
+            out << "," << zone->getFailSafe(failsafePercent) << std::endl;
+            zone->writeLog(out.str());
+        }
+
+        ms100cnt += 1;
+        checkFanFailuresCount += 1;
+
+        /* If last output pwm and current output pwm are different.
+         * Reset check fan failures counter.
+         */
+        if (zone->getCheckFanFailuresFlag() == false)
+        {
+            checkFanFailuresCount = 0;
+        }
+
+        pidControlLoop(zone, timer, false, ms100cnt, checkFanFailuresCount);
+    });
 }
 
 } // namespace pid_control
diff --git a/pid/pidloop.hpp b/pid/pidloop.hpp
index b7d1b34..cdfb06c 100644
--- a/pid/pidloop.hpp
+++ b/pid/pidloop.hpp
@@ -19,6 +19,7 @@ namespace pid_control
  */
 void pidControlLoop(std::shared_ptr<ZoneInterface> zone,
                     std::shared_ptr<boost::asio::steady_timer> timer,
-                    bool first = true, int ms100cnt = 0);
+                    bool first = true, uint64_t ms100cnt = 0,
+                    uint64_t checkFanFailuresCount = 0);
 
 } // namespace pid_control
diff --git a/pid/stepwisecontroller.cpp b/pid/stepwisecontroller.cpp
index ed0798a..cfbcca6 100644
--- a/pid/stepwisecontroller.cpp
+++ b/pid/stepwisecontroller.cpp
@@ -38,6 +38,12 @@ void StepwiseController::process(void)
     // Get input value
     double input = inputProc();
 
+    // There is no inputs stepwise can use in this controller, skip it.
+    if (input == std::numeric_limits<double>::lowest())
+    {
+        return;
+    }
+
     ec::StepwiseInfo info = getStepwiseInfo();
 
     double output = lastOutput;
@@ -70,13 +76,6 @@ std::unique_ptr<Controller> StepwiseController::createStepwiseController(
     ZoneInterface* owner, const std::string& id, const std::string& type,
     const std::vector<std::string>& inputs, const ec::StepwiseInfo& initial)
 {
-    // StepwiseController requires at least 1 input
-    if (inputs.empty())
-    {
-        throw ControllerBuildException("Stepwise controller missing inputs");
-        return nullptr;
-    }
-
     auto thermal =
         std::make_unique<StepwiseController>(id, type, inputs, owner);
     thermal->setStepwiseInfo(initial);
diff --git a/pid/thermalcontroller.cpp b/pid/thermalcontroller.cpp
index 5d9329a..af65036 100644
--- a/pid/thermalcontroller.cpp
+++ b/pid/thermalcontroller.cpp
@@ -44,13 +44,6 @@ std::unique_ptr<PIDController> ThermalController::createThermalPid(
     const std::vector<std::string>& inputs, double setpoint,
     const ec::pidinfo& initial, const ThermalType& type)
 {
-    // ThermalController requires at least 1 input
-    if (inputs.empty())
-    {
-        throw ControllerBuildException("Thermal controller missing inputs");
-        return nullptr;
-    }
-
     auto thermal = std::make_unique<ThermalController>(id, inputs, type, owner);
 
     ec::pid_info_t* info = thermal->getPIDInfo();
diff --git a/pid/zone.cpp b/pid/zone.cpp
index 9a38b29..b22fc70 100644
--- a/pid/zone.cpp
+++ b/pid/zone.cpp
@@ -15,19 +15,30 @@
  */
 
 /* Configuration. */
+#include "config.h"
+
 #include "zone.hpp"
 
 #include "conf.hpp"
+#include "dbus/dbuspassive.hpp"
 #include "pid/controller.hpp"
 #include "pid/ec/pid.hpp"
+#include "pid/ec/stepwise.hpp"
 #include "pid/fancontroller.hpp"
 #include "pid/stepwisecontroller.hpp"
 #include "pid/thermalcontroller.hpp"
 #include "pid/tuning.hpp"
+#include "sensors/build_utils.hpp"
+#include "sensors/builder.hpp"
+#include "sensors/pluggable.hpp"
+
+#include <boost/algorithm/string/predicate.hpp>
 
 #include <algorithm>
 #include <chrono>
+#include <cmath>
 #include <cstring>
+#include <filesystem>
 #include <fstream>
 #include <iostream>
 #include <memory>
@@ -84,10 +95,146 @@ void DbusPidZone::setManualMode(bool mode)
     _manualMode = mode;
 }
 
-bool DbusPidZone::getFailSafeMode(void) const
+bool DbusPidZone::getFailSafe(double& failsafePercent) const
 {
-    // If any keys are present at least one sensor is in fail safe mode.
-    return !_failSafeSensors.empty();
+    static bool fanFailPrint = false;
+    static bool sensorFailPrint = false;
+    double fanFailsafePercent = 0.0;
+    double sensorFailsafePercent = 0.0;
+    if (_failSafeFans.size() != 0)
+    {
+        for (const auto& profile : _failsafeSetting.fanFailsafeProfiles)
+        {
+            /*
+             * Because fanFailsafeProfiles are sorted with fanFailCount,
+             * The first item has the largest fanFailCount value.
+             * So the former one is more critical than the later one in
+             * fanFailsafeProfiles.
+             */
+            if (_failSafeFans.size() >= profile.fanFailCount)
+            {
+                if (profile.outputType == "value")
+                {
+                    fanFailsafePercent = profile.failsafePercent;
+                }
+                // Linear or Stepwise
+                else
+                {
+                    // Get the max value in the inputs.
+                    double maxInput = std::numeric_limits<double>::lowest();
+                    for (const auto& input : profile.inputs)
+                    {
+                        auto inputFind = _cachedValuesByName.find(input);
+                        if (inputFind != _cachedValuesByName.end())
+                        {
+                            maxInput = std::max(maxInput, inputFind->second);
+                        }
+                    }
+
+                    if (profile.outputType == "stepwise")
+                    {
+                        fanFailsafePercent = ec::stepwise(
+                            profile.reading, profile.output, maxInput);
+                    }
+                    else if (profile.outputType == "linear")
+                    {
+                        fanFailsafePercent = ec::linear(
+                            profile.reading, profile.output, maxInput);
+                    }
+                    else
+                    {
+                        // Should not reach here.
+                        std::cerr << "Unknown outputType\n";
+                    }
+                }
+            }
+        }
+    }
+
+    for (const auto& it : _failSafeTemps)
+    {
+        for (const auto& profile : _failsafeSetting.sensorFailsafeProfiles)
+        {
+            auto sensorFind = std::find(profile.sensorNames.begin(),
+                                        profile.sensorNames.end(), it);
+            if (sensorFind != profile.sensorNames.end())
+            {
+                if (profile.outputType == "value")
+                {
+                    sensorFailsafePercent = std::max(sensorFailsafePercent,
+                                                     profile.failsafePercent);
+                }
+                // Linear or Stepwise
+                else
+                {
+                    // Get the max value in the inputs.
+                    double maxInput = std::numeric_limits<double>::lowest();
+                    for (const auto& input : profile.inputs)
+                    {
+                        auto inputFind = _cachedValuesByName.find(input);
+                        if (inputFind != _cachedValuesByName.end())
+                        {
+                            maxInput = std::max(maxInput, inputFind->second);
+                        }
+                    }
+
+                    if (profile.outputType == "stepwise")
+                    {
+                        sensorFailsafePercent =
+                            std::max(sensorFailsafePercent,
+                                     ec::stepwise(profile.reading,
+                                                  profile.output, maxInput));
+                    }
+                    else if (profile.outputType == "linear")
+                    {
+                        sensorFailsafePercent =
+                            std::max(sensorFailsafePercent,
+                                     ec::linear(profile.reading, profile.output,
+                                                maxInput));
+                    }
+                    else
+                    {
+                        // Should not reach here.
+                        std::cerr << "Unknown outputType\n";
+                    }
+                }
+            }
+
+            break;
+        }
+    }
+
+    if (fanFailsafePercent == 0.0)
+    {
+        fanFailPrint = false;
+    }
+    else if ((debugModeEnabled == true) || (fanFailPrint == false))
+    {
+        std::cerr << "Zone " << getZoneID()
+                  << " enter failsafe mode: fan failures\n";
+        fanFailPrint = true;
+    }
+
+    if (sensorFailsafePercent == 0.0)
+    {
+        sensorFailPrint = false;
+    }
+    else if ((debugModeEnabled == true) || (sensorFailPrint == false))
+    {
+        std::cerr << "Zone " << getZoneID()
+                  << " enter failsafe mode: sensor failures\n";
+        sensorFailPrint = true;
+    }
+
+    failsafePercent = std::max(fanFailsafePercent, sensorFailsafePercent);
+    if (failsafePercent != 0.0)
+    {
+        return true;
+    }
+    else
+    {
+        return false;
+    }
 }
 
 int64_t DbusPidZone::getZoneID(void) const
@@ -118,16 +265,36 @@ void DbusPidZone::clearSetPoints(void)
     }
 }
 
-double DbusPidZone::getFailSafePercent(void) const
+double DbusPidZone::getMinThermalSetpoint(void) const
 {
-    return _failSafePercent;
+    return _minThermalOutputSetPt;
 }
 
-double DbusPidZone::getMinThermalSetpoint(void) const
+uint64_t DbusPidZone::getCycleTimeBase(void) const
 {
-    return _minThermalOutputSetPt;
+    return _cycleTimeBase;
+}
+
+uint64_t DbusPidZone::getCheckFanFailuresCycle(void) const
+{
+    return _checkFanFailuresCycle;
+}
+
+uint64_t DbusPidZone::getUpdateThermalsCycle(void) const
+{
+    return _updateThermalsCycle;
+}
+
+void DbusPidZone::setCheckFanFailuresFlag(bool value)
+{
+    _checkFanFailuresFlag = value;
 }
 
+bool DbusPidZone::getCheckFanFailuresFlag(void) const
+{
+    return _checkFanFailuresFlag;
+ }
+
 void DbusPidZone::addFanPID(std::unique_ptr<Controller> pid)
 {
     _fans.push_back(std::move(pid));
@@ -150,7 +317,7 @@ void DbusPidZone::addFanInput(const std::string& fan)
 
 void DbusPidZone::addThermalInput(const std::string& therm)
 {
-    _thermalInputs.push_back(therm);
+    _thermalInputs.insert(therm);
 }
 
 // Updates desired RPM setpoint from optional text file
@@ -227,6 +394,12 @@ void DbusPidZone::determineMaxSetPointRequest(void)
         }
     }
 
+    // If there is no output pwm we can use, just run default pwm.
+    else
+    {
+        max = DEFAULT_PWM;
+    }
+
     if (_RPMCeilings.size() > 0)
     {
         std::vector<double>::iterator resultRPMCeiling;
@@ -323,7 +496,19 @@ void DbusPidZone::updateFanTelemetry(void)
     for (const auto& f : _fanInputs)
     {
         auto sensor = _mgr.getSensor(f);
+        if (sensor->isReadable() == false)
+        {
+            _failSafeFans.insert(f);
+            continue;
+        }
+
         ReadReturn r = sensor->read();
+
+        if (debugModeEnabled)
+        {
+            std::cerr << f << " fan sensor reading: " << r.value << "\n";
+        }
+
         _cachedValuesByName[f] = r.value;
         int64_t timeout = sensor->getTimeout();
         tstamp then = r.updated;
@@ -343,30 +528,68 @@ void DbusPidZone::updateFanTelemetry(void)
         }
 
         // check if fan fail.
-        auto failsafeFind = _failSafeSensors.find(f);
+        auto failsafeFind = _failSafeFans.find(f);
         if (sensor->getFailed())
         {
-            if (failsafeFind == _failSafeSensors.end())
+            if (failsafeFind == _failSafeFans.end() || debugModeEnabled)
             {
                 std::cerr << f << " fan sensor get failed\n";
-                _failSafeSensors.insert(f);
+                _failSafeFans.insert(f);
             }
         }
         else if (timeout != 0 && duration >= period)
         {
-            if (failsafeFind == _failSafeSensors.end())
+            // Try to connect with sensor D-Bus if failed it is really timeout.
+            try
             {
-                std::cerr << f << " fan sensor timeout\n";
-                _failSafeSensors.insert(f);
+                auto service = _helper.getService(
+                    sensorintf, sensor->getSensorInfo()->readPath);
+
+                struct SensorProperties properties;
+                _helper.getProperties(
+                    service, sensor->getSensorInfo()->readPath, &properties);
+                _cachedValuesByName[f] = properties.value;
+
+                bool available = true;
+                _helper.getProperty<bool>(
+                    service, sensor->getSensorInfo()->readPath,
+                    DbusHelper::availableIntf, "Available", available);
+
+                bool functional = true;
+                _helper.getProperty<bool>(
+                    service, sensor->getSensorInfo()->readPath,
+                    DbusHelper::functionalIntf, "Functional", functional);
+
+                if (available == false || functional == false)
+                {
+                    if (failsafeFind == _failSafeTemps.end() ||
+                        debugModeEnabled)
+                    {
+                        std::cerr << f << " fan sensor getfailed\n";
+                        _failSafeTemps.insert(f);
+                    }
+                }
+            }
+            catch (...)
+            {
+                if (failsafeFind == _failSafeFans.end() || debugModeEnabled)
+                {
+                    std::cerr << f << " fan sensor timeout\n";
+                    _failSafeFans.insert(f);
+                }
             }
         }
         else
         {
-            // Check if it's in there: remove it.
-            if (failsafeFind == _failSafeSensors.end())
+            /*
+             * If it's in failsafe fan set, remove it.
+             * If this fan is added by checkFanFailures do not remove it.
+             */
+            if ((failsafeFind != _failSafeFans.end()) &&
+                (_isFanFailure[f] == false))
             {
                 std::cerr << f << " is erased from failsafe fan set\n";
-                _failSafeSensors.erase(failsafeFind);
+                _failSafeFans.erase(failsafeFind);
             }
         }
     }
@@ -382,6 +605,66 @@ void DbusPidZone::updateFanTelemetry(void)
     return;
 }
 
+void DbusPidZone::checkFanFailures(void)
+{
+    std::map<std::string, double> fanSpeeds;
+    double firstLargestFanTach = 0;
+    double secondLargestFanTach = 0;
+    double value = 0;
+    double twoLargestAverage = 0;
+
+    // Get the fan speeds.
+    for (const auto& name : _fanInputs)
+    {
+        value = _cachedValuesByName[name];
+        fanSpeeds[name] = value;
+
+        // Find the two largest fan speeds.
+        if (value > secondLargestFanTach)
+        {
+            if (value > firstLargestFanTach)
+            {
+                secondLargestFanTach = firstLargestFanTach;
+                firstLargestFanTach = value;
+            }
+            else
+            {
+                secondLargestFanTach = value;
+            }
+        }
+    }
+
+    twoLargestAverage = (firstLargestFanTach + secondLargestFanTach) / 2;
+
+    /*
+     * If a fan tachometer value is 25% below the twoLargestAverage
+     * log a SEL to indicate a suspected failure on this fan.
+     */
+    for (auto& it : fanSpeeds)
+    {
+        if (it.second < (twoLargestAverage * 0.75))
+        {
+            std::cerr << it.first << " is 25% below the average\n";
+            _failSafeFans.insert(it.first);
+            _isFanFailure[it.first] = true;
+        }
+        else
+        {
+            /*
+             * Another sides place fans in failSafeFans.
+             * Do not erase them from set.
+             */
+            if (_isFanFailure[it.first] == true)
+            {
+                _failSafeFans.erase(it.first);
+            }
+            _isFanFailure[it.first] = false;
+        }
+    }
+
+    return;
+}
+
 void DbusPidZone::updateSensors(void)
 {
     using namespace std::chrono;
@@ -391,6 +674,77 @@ void DbusPidZone::updateSensors(void)
     for (const auto& t : _thermalInputs)
     {
         auto sensor = _mgr.getSensor(t);
+
+        // Check sensor is readable or not.
+        const struct conf::SensorConfig* info = sensor->getSensorInfo();
+        if ((sensor->isReadable() == false) &&
+            (getReadInterfaceType(info->readPath) ==
+             IOInterfaceType::DBUSPASSIVE))
+        {
+            // Try to connect to sensor dbus object.
+            std::unique_ptr<ReadInterface> ri = DbusPassive::createDbusPassive(
+                _mgr.getPassiveBus(), info->type, sensor->getName(),
+                std::make_unique<DbusHelper>(sdbusplus::bus::new_system()),
+                info, nullptr);
+
+            if (ri != nullptr)
+            {
+                /*
+                 * Connect to dbus successfully, start reinitializing sensor
+                 * reader and zone's pid/stepwise profiles.
+                 */
+                std::cerr << sensor->getName() << " start reinitializing\n";
+
+                // Convert base class pointer to derived class pointer.
+                PluggableSensor* plugSensor =
+                    dynamic_cast<PluggableSensor*>(sensor);
+                plugSensor->setReader(std::move(ri));
+                double tjMax =
+                    getTjMaxFromPath(info->tjMaxPath, info->tjMaxScale);
+                if (tjMax != 0)
+                {
+                    plugSensor->setTjMax(tjMax);
+                    for (auto& p : _thermals)
+                    {
+                        // Find which sensor does this controller belong to.
+                        if (p->getProfileName() == t)
+                        {
+                            std::size_t profileTypePos = p->getID().find("_");
+                            std::string profileType =
+                                p->getID().substr(0, profileTypePos);
+                            if (profileType == "PID")
+                            {
+                                // Adjust setpoint for PID profile.
+                                PIDController* pp =
+                                    dynamic_cast<PIDController*>(p.get());
+                                pp->setSetpoint(pp->getSetpoint() + tjMax);
+                            }
+                            else if ((profileType == "Stepwise") ||
+                                     (profileType == "Linear"))
+                            {
+                                /*
+                                 * Adjust reading points for stepwise/linear
+                                 * profile.
+                                 */
+                                StepwiseController* sp =
+                                    dynamic_cast<StepwiseController*>(p.get());
+                                for (auto& point :
+                                     sp->getStepwiseInfo().reading)
+                                {
+                                    point = tjMax + point;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+            else
+            {
+                // If sensor is not readable, skip it.
+                continue;
+            }
+        }
+
         ReadReturn r = sensor->read();
         int64_t timeout = sensor->getTimeout();
 
@@ -406,30 +760,64 @@ void DbusPidZone::updateSensors(void)
         auto duration = duration_cast<std::chrono::seconds>(now - then).count();
         auto period = std::chrono::seconds(timeout).count();
 
-        auto failsafeFind = _failSafeSensors.find(t);
+        auto failsafeFind = _failSafeTemps.find(t);
         if (sensor->getFailed())
         {
-            if (failsafeFind == _failSafeSensors.end())
+            if (failsafeFind == _failSafeTemps.end() || debugModeEnabled)
             {
                 std::cerr << t << " temperature sensor getfailed\n";
-                _failSafeSensors.insert(t);
+                _failSafeTemps.insert(t);
             }
         }
         else if (timeout != 0 && duration >= period)
         {
-            if (failsafeFind == _failSafeSensors.end())
+            // Try to connect with sensor D-Bus if failed it is really timeout.
+            try
             {
-                std::cerr << t << " temperature sensor timeout\n";
-                _failSafeSensors.insert(t);
+                auto service = _helper.getService(
+                    sensorintf, sensor->getSensorInfo()->readPath);
+
+                struct SensorProperties properties;
+                _helper.getProperties(
+                    service, sensor->getSensorInfo()->readPath, &properties);
+                _cachedValuesByName[t] = properties.value;
+
+                bool available = true;
+                _helper.getProperty<bool>(
+                    service, sensor->getSensorInfo()->readPath,
+                    DbusHelper::availableIntf, "Available", available);
+
+                bool functional = true;
+                _helper.getProperty<bool>(
+                    service, sensor->getSensorInfo()->readPath,
+                    DbusHelper::functionalIntf, "Functional", functional);
+
+                if (available == false || functional == false)
+                {
+                    if (failsafeFind == _failSafeTemps.end() ||
+                        debugModeEnabled)
+                    {
+                        std::cerr << t << " temperature sensor getfailed\n";
+                        _failSafeTemps.insert(t);
+                    }
+                }
+            }
+            catch (...)
+            {
+                if (failsafeFind == _failSafeTemps.end() || debugModeEnabled)
+                {
+                    std::cerr << t << " temperature sensor timeout\n";
+                    _failSafeTemps.insert(t);
+                }
             }
         }
         else
         {
             // Check if it's in there: remove it.
-            if (failsafeFind == _failSafeSensors.end())
+            if (failsafeFind != _failSafeTemps.end())
             {
                 std::cerr << t << " is erased from failsafe sensor set\n";
-                _failSafeSensors.erase(failsafeFind);
+                _failSafeTemps.erase(failsafeFind);
             }
         }
     }
@@ -442,17 +830,16 @@ void DbusPidZone::initializeCache(void)
     for (const auto& f : _fanInputs)
     {
         _cachedValuesByName[f] = 0;
+        _isFanFailure[f] = false;
 
         // Start all fans in fail-safe mode.
-        _failSafeSensors.insert(f);
+        _failSafeFans.insert(f);
     }
 
     for (const auto& t : _thermalInputs)
     {
-        _cachedValuesByName[t] = 0;
-
-        // Start all sensors in fail-safe mode.
-        _failSafeSensors.insert(t);
+        _cachedValuesByName[t] = std::numeric_limits<double>::lowest();
+        _failSafeTemps.insert(t);
     }
 }
 
@@ -488,14 +875,15 @@ Sensor* DbusPidZone::getSensor(const std::string& name)
 
 bool DbusPidZone::manual(bool value)
 {
-    std::cerr << "manual: " << value << std::endl;
+    std::cerr << "zone " << getZoneID() << " manual: " << value << std::endl;
     setManualMode(value);
     return ModeObject::manual(value);
 }
 
 bool DbusPidZone::failSafe() const
 {
-    return getFailSafeMode();
+    double failsafePercent = 0.0;
+    return getFailSafe(failsafePercent);
 }
 
 } // namespace pid_control
diff --git a/pid/zone.hpp b/pid/zone.hpp
index d8189e4..c9248e9 100644
--- a/pid/zone.hpp
+++ b/pid/zone.hpp
@@ -2,6 +2,7 @@
 
 #include "conf.hpp"
 #include "controller.hpp"
+#include "dbus/dbushelper.hpp"
 #include "pidcontroller.hpp"
 #include "sensors/manager.hpp"
 #include "sensors/sensor.hpp"
@@ -35,13 +36,18 @@ namespace pid_control
 class DbusPidZone : public ZoneInterface, public ModeObject
 {
   public:
-    DbusPidZone(int64_t zone, double minThermalOutput, double failSafePercent,
-                const SensorManager& mgr, sdbusplus::bus::bus& bus,
-                const char* objPath, bool defer) :
+    DbusPidZone(int64_t zone, double minThermalOutput,
+                struct conf::FailsafeSetting failsafeSetting,
+                uint64_t cycleTimeBase, uint64_t checkFanFailuresTime,
+                uint64_t updateThermalsTime, const SensorManager& mgr,
+                sdbusplus::bus::bus& bus, const char* objPath, bool defer) :
         ModeObject(bus, objPath, defer),
         _zoneId(zone), _maximumSetPoint(),
         _minThermalOutputSetPt(minThermalOutput),
-        _failSafePercent(failSafePercent), _mgr(mgr)
+        _failsafeSetting(failsafeSetting), _cycleTimeBase(cycleTimeBase),
+        _checkFanFailuresCycle(checkFanFailuresTime / cycleTimeBase),
+        _updateThermalsCycle(updateThermalsTime / cycleTimeBase), _mgr(mgr),
+        _helper(sdbusplus::bus::new_system())
     {
         if (loggingEnabled)
         {
@@ -54,20 +60,25 @@ class DbusPidZone : public ZoneInterface, public ModeObject
      * only one reader/one writer.
      */
     void setManualMode(bool mode);
-    bool getFailSafeMode(void) const override;
+    bool getFailSafe(double& failsafePercent) const override;
 
-    int64_t getZoneID(void) const;
+    int64_t getZoneID(void) const override;
     void addSetPoint(std::string profileName, double setpoint) override;
     double getMaxSetPointRequest(void) const override;
     void addRPMCeiling(double ceiling) override;
     void clearSetPoints(void) override;
     void clearRPMCeilings(void) override;
-    double getFailSafePercent(void) const override;
     double getMinThermalSetpoint(void) const;
+    uint64_t getCycleTimeBase(void) const override;
+    uint64_t getCheckFanFailuresCycle(void) const override;
+    uint64_t getUpdateThermalsCycle(void) const override;
+    void setCheckFanFailuresFlag(bool value) override;
+    bool getCheckFanFailuresFlag(void) const override;
 
     Sensor* getSensor(const std::string& name) override;
     void determineMaxSetPointRequest(void) override;
     void updateFanTelemetry(void) override;
+    void checkFanFailures(void) override;
     void updateSensors(void) override;
     void initializeCache(void) override;
     void dumpCache(void);
@@ -95,16 +106,23 @@ class DbusPidZone : public ZoneInterface, public ModeObject
     double _maximumSetPoint = 0;
     bool _manualMode = false;
     const double _minThermalOutputSetPt;
-    const double _failSafePercent;
+    struct conf::FailsafeSetting _failsafeSetting;
+    const uint64_t _cycleTimeBase;
+    const uint64_t _checkFanFailuresCycle;
+    const uint64_t _updateThermalsCycle;
+    bool _checkFanFailuresFlag = false;
 
-    std::set<std::string> _failSafeSensors;
+    std::set<std::string> _failSafeTemps;
+    std::set<std::string> _failSafeFans;
+    std::map<std::string, bool> _isFanFailure;
 
     std::map<std::string, double> _SetPoints;
     std::vector<double> _RPMCeilings;
     std::vector<std::string> _fanInputs;
-    std::vector<std::string> _thermalInputs;
+    std::set<std::string> _thermalInputs;
     std::map<std::string, double> _cachedValuesByName;
     const SensorManager& _mgr;
+    DbusHelper _helper;
 
     std::vector<std::unique_ptr<Controller>> _fans;
     std::vector<std::unique_ptr<Controller>> _thermals;
diff --git a/pid/zone_interface.hpp b/pid/zone_interface.hpp
index 7c9a688..63ac01e 100644
--- a/pid/zone_interface.hpp
+++ b/pid/zone_interface.hpp
@@ -16,6 +16,9 @@ class ZoneInterface
   public:
     virtual ~ZoneInterface() = default;
 
+    /** Get Current Zone ID */
+    virtual int64_t getZoneID(void) const = 0;
+
     /** If the zone implementation supports logging, initialize the log. */
     virtual void initializeLog(void) = 0;
     /** If the zone implementation supports logging, write string to log. */
@@ -24,6 +27,13 @@ class ZoneInterface
     /** Return a pointer to the sensor specified by name. */
     virtual Sensor* getSensor(const std::string& name) = 0;
 
+    /** Method for set/get last pwm and current pwm are different. */
+    virtual void setCheckFanFailuresFlag(bool value) = 0;
+    virtual bool getCheckFanFailuresFlag() const = 0;
+
+    /** Cheak whether fans are failed. */
+    virtual void checkFanFailures(void) = 0;
+
     /* updateFanTelemetry() and updateSensors() both clear the failsafe state
      * for a sensor if it's no longer in that state.
      */
@@ -65,11 +75,12 @@ class ZoneInterface
     virtual double getMaxSetPointRequest() const = 0;
 
     /** Return if the zone has any sensors in fail safe mode. */
-    virtual bool getFailSafeMode() const = 0;
-    /** Return the rpm or pwm percent value to drive fan pids when zone is in
-     * fail safe.
-     */
-    virtual double getFailSafePercent() const = 0;
+    virtual bool getFailSafe(double& failsafePercent) const = 0;
+
+    /** Return fan table defined time settings */
+    virtual uint64_t getCycleTimeBase(void) const = 0;
+    virtual uint64_t getCheckFanFailuresCycle(void) const = 0;
+    virtual uint64_t getUpdateThermalsCycle(void) const = 0;
 
     /** Return if the zone is set to manual mode.  false equates to automatic
      * mode (the default).
diff --git a/sensors/builder.cpp b/sensors/builder.cpp
index f4257ad..6bb90c5 100644
--- a/sensors/builder.cpp
+++ b/sensors/builder.cpp
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+#include <fstream>
 #include <iostream>
 #include <map>
 #include <memory>
@@ -96,9 +97,9 @@ SensorManager
                 }
                 if (ri == nullptr)
                 {
-                    throw SensorBuildException(
-                        "Failed to create dbus passive sensor: " + name +
-                        " of type: " + info->type);
+                    std::cerr
+                        << "Failed to create dbus passive sensor: " << name
+                        << " of type: " << info->type << "\n";
                 }
                 break;
             case IOInterfaceType::EXTERNAL:
@@ -159,15 +160,21 @@ SensorManager
             }
 
             auto sensor = std::make_unique<PluggableSensor>(
-                name, info->timeout, std::move(ri), std::move(wi));
+                name, info->timeout, std::move(ri), std::move(wi), info);
             mgmr.addSensor(info->type, name, std::move(sensor));
         }
-        else if (info->type == "temp" || info->type == "margin")
+        else if ((info->type == "temp") || (info->type == "margin"))
         {
             // These sensors are read-only, but only for this application
             // which only writes to fan sensors.
             std::cerr << info->type << " readPath: " << info->readPath << "\n";
 
+            double tjMax = 0;
+            if (ri != nullptr)
+            {
+                tjMax = getTjMaxFromPath(info->tjMaxPath, info->tjMaxScale);
+            }
+
             if (IOInterfaceType::EXTERNAL == rtype)
             {
                 std::cerr << "Creating HostSensor: " << name
@@ -179,14 +186,15 @@ SensorManager
                  */
                 auto sensor = HostSensor::createTemp(
                     name, info->timeout, hostSensorBus, info->readPath.c_str(),
-                    deferSignals);
+                    deferSignals, info, tjMax);
                 mgmr.addSensor(info->type, name, std::move(sensor));
             }
             else
             {
                 wi = std::make_unique<ReadOnlyNoExcept>();
                 auto sensor = std::make_unique<PluggableSensor>(
-                    name, info->timeout, std::move(ri), std::move(wi));
+                    name, info->timeout, std::move(ri), std::move(wi), info,
+                    tjMax);
                 mgmr.addSensor(info->type, name, std::move(sensor));
             }
         }
diff --git a/sensors/buildjson.cpp b/sensors/buildjson.cpp
index c320fe1..5c68247 100644
--- a/sensors/buildjson.cpp
+++ b/sensors/buildjson.cpp
@@ -45,6 +45,34 @@ void from_json(const json& j, conf::SensorConfig& s)
         j.at("writePath").get_to(s.writePath);
     }
 
+    /*
+     * The tjMaxPath field is used when temp is margin,
+     * but dbus reading value is absolute temperature value.
+     */
+    auto tjMaxPath = j.find("tjMaxPath");
+    if (tjMaxPath == j.end())
+    {
+        s.tjMaxPath = "";
+    }
+    else
+    {
+        j.at("tjMaxPath").get_to(s.tjMaxPath);
+    }
+
+    /*
+     * The tjMaxSale field is used to scale the tjMax value which
+     * read from PECI driver.
+     */
+    auto tjMaxScale = j.find("tjMaxScale");
+    if (tjMaxScale == j.end())
+    {
+        s.tjMaxScale = 1.0;
+    }
+    else
+    {
+        j.at("tjMaxScale").get_to(s.tjMaxScale);
+    }
+
     /* Default to not ignore dbus MinValue/MaxValue - only used by passive
      * sensors.
      */
diff --git a/sensors/host.cpp b/sensors/host.cpp
index 53f114e..f92b614 100644
--- a/sensors/host.cpp
+++ b/sensors/host.cpp
@@ -33,13 +33,14 @@ void scaleHelper(T& ptr, int64_t value)
     }
 }
 
-std::unique_ptr<Sensor> HostSensor::createTemp(const std::string& name,
-                                               int64_t timeout,
-                                               sdbusplus::bus::bus& bus,
-                                               const char* objPath, bool defer)
+std::unique_ptr<Sensor>
+    HostSensor::createTemp(const std::string& name, int64_t timeout,
+                           sdbusplus::bus::bus& bus, const char* objPath,
+                           bool defer, const struct conf::SensorConfig* info,
+                           double tjMax)
 {
-    auto sensor =
-        std::make_unique<HostSensor>(name, timeout, bus, objPath, defer);
+    auto sensor = std::make_unique<HostSensor>(name, timeout, bus, objPath,
+                                               defer, info, tjMax);
     sensor->value(0);
 
     // DegreesC and value of 0 are the defaults at present, therefore testing
diff --git a/sensors/host.hpp b/sensors/host.hpp
index 35c7f45..0733bba 100644
--- a/sensors/host.hpp
+++ b/sensors/host.hpp
@@ -40,14 +40,15 @@ using ValueType = std::conditional_t<usingDouble, double, int64_t>;
 class HostSensor : public Sensor, public ValueObject
 {
   public:
-    static std::unique_ptr<Sensor> createTemp(const std::string& name,
-                                              int64_t timeout,
-                                              sdbusplus::bus::bus& bus,
-                                              const char* objPath, bool defer);
+    static std::unique_ptr<Sensor>
+        createTemp(const std::string& name, int64_t timeout,
+                   sdbusplus::bus::bus& bus, const char* objPath, bool defer,
+                   const struct conf::SensorConfig* info, double tjMax);
 
     HostSensor(const std::string& name, int64_t timeout,
-               sdbusplus::bus::bus& bus, const char* objPath, bool defer) :
-        Sensor(name, timeout),
+               sdbusplus::bus::bus& bus, const char* objPath, bool defer,
+               const struct conf::SensorConfig* info, double tjMax = 0) :
+        Sensor(name, timeout, info, tjMax),
         ValueObject(bus, objPath, defer)
     {}
 
diff --git a/sensors/manager.hpp b/sensors/manager.hpp
index 6fcd275..959dd53 100644
--- a/sensors/manager.hpp
+++ b/sensors/manager.hpp
@@ -45,12 +45,12 @@ class SensorManager
         return _sensorMap.at(name).get();
     }
 
-    sdbusplus::bus::bus& getPassiveBus(void)
+    sdbusplus::bus::bus& getPassiveBus(void) const
     {
         return *_passiveListeningBus;
     }
 
-    sdbusplus::bus::bus& getHostBus(void)
+    sdbusplus::bus::bus& getHostBus(void) const
     {
         return *_hostSensorBus;
     }
diff --git a/sensors/pluggable.hpp b/sensors/pluggable.hpp
index 0dc1c71..05725b3 100644
--- a/sensors/pluggable.hpp
+++ b/sensors/pluggable.hpp
@@ -1,5 +1,7 @@
 #pragma once
 
+#include "conf.hpp"
+#include "dbus/dbuspassive.hpp"
 #include "interfaces.hpp"
 #include "sensor.hpp"
 
@@ -17,8 +19,10 @@ class PluggableSensor : public Sensor
   public:
     PluggableSensor(const std::string& name, int64_t timeout,
                     std::unique_ptr<ReadInterface> reader,
-                    std::unique_ptr<WriteInterface> writer) :
-        Sensor(name, timeout),
+                    std::unique_ptr<WriteInterface> writer,
+                    const struct conf::SensorConfig* info = nullptr,
+                    double tjMax = 0) :
+        Sensor(name, timeout, info, tjMax),
         _reader(std::move(reader)), _writer(std::move(writer))
     {}
 
@@ -26,6 +30,15 @@ class PluggableSensor : public Sensor
     void write(double value) override;
     void write(double value, bool force, int64_t* written) override;
     bool getFailed(void) override;
+    bool isReadable(void) const override
+    {
+        return (_reader == nullptr) ? false : true;
+    }
+
+    void setReader(std::unique_ptr<ReadInterface> reader)
+    {
+        _reader = std::move(reader);
+    }
 
   private:
     std::unique_ptr<ReadInterface> _reader;
diff --git a/sensors/sensor.hpp b/sensors/sensor.hpp
index f5f01c2..0fbb0ae 100644
--- a/sensors/sensor.hpp
+++ b/sensors/sensor.hpp
@@ -1,6 +1,8 @@
 #pragma once
 
+#include "conf.hpp"
 #include "interfaces.hpp"
+#include "util.hpp"
 
 #include <string>
 
@@ -27,8 +29,10 @@ class Sensor
         return (type == "fan") ? 0 : 2;
     }
 
-    Sensor(const std::string& name, int64_t timeout) :
-        _name(name), _timeout(timeout)
+    Sensor(const std::string& name, int64_t timeout,
+           const struct conf::SensorConfig* info, double tjMax) :
+        _name(name),
+        _timeout(timeout), _info(info), _tjMax(tjMax)
     {}
 
     virtual ~Sensor()
@@ -49,6 +53,11 @@ class Sensor
         return false;
     };
 
+    virtual bool isReadable(void) const
+    {
+        return true;
+    }
+
     std::string getName(void) const
     {
         return _name;
@@ -62,9 +71,26 @@ class Sensor
         return _timeout;
     }
 
+    double getTjMax(void) const
+    {
+        return _tjMax;
+    }
+
+    void setTjMax(double tjMax)
+    {
+        _tjMax = tjMax;
+    }
+
+    const struct conf::SensorConfig* const getSensorInfo(void) const
+    {
+        return _info;
+    }
+
   private:
     std::string _name;
     int64_t _timeout;
+    const struct conf::SensorConfig* _info;
+    double _tjMax;
 };
 
 } // namespace pid_control
diff --git a/sysfs/util.cpp b/sysfs/util.cpp
index b7cc6f3..c8b022c 100644
--- a/sysfs/util.cpp
+++ b/sysfs/util.cpp
@@ -17,6 +17,7 @@
 #include "util.hpp"
 
 #include <filesystem>
+#include <fstream>
 #include <iostream>
 #include <string>
 
@@ -24,16 +25,21 @@ namespace pid_control
 {
 
 /*
- * There are two basic paths I want to support:
+ * There are four basic paths I want to support:
  * 1. /sys/class/hwmon/hwmon0/pwm1
  * 2. /sys/devices/platform/ahb/1e786000.pwm-tacho-controller/hwmon/<asterisk
  * asterisk>/pwm1
- *
+ * 3. /sys/bus/peci/devices/0-30/peci-cputemp.0/hwmon/<asteriskasterisk>/
+ * tempN_input
+ * 4. /sys/bus/i2c/devices/1-0020/hwmon/<asterisk asterisk>/pwm1
  * In this latter case, I want to fill in that gap.  Assuming because it's this
  * path that it'll only have one directory there.
  */
 
-static constexpr auto platform = "/sys/devices/platform/";
+std::vector<std::string> supportPath = {"/sys/devices/platform/",
+                                        "/sys/bus/peci/devices/",
+                                        "/sys/bus/i2c/devices/"};
+
 namespace fs = std::filesystem;
 
 std::string FixupPath(std::string original)
@@ -42,7 +48,16 @@ std::string FixupPath(std::string original)
 
     /* TODO: Consider the merits of using regex for this. */
     n = original.find("**");
-    x = original.find(platform);
+
+    x = std::string::npos;
+    for (auto& path : supportPath)
+    {
+        x = original.find(path);
+        if (x != std::string::npos)
+        {
+            break;
+        }
+    }
 
     if ((n != std::string::npos) && (x != std::string::npos))
     {
@@ -72,4 +87,83 @@ std::string FixupPath(std::string original)
     }
 }
 
+double getTjMaxFromPath(const std::string& tjMaxPath, double tjMaxScale)
+{
+    // Read the Tjmax value from the tjMaxPath given by json file.
+    double tjMax = 0;
+    if (tjMaxPath != "")
+    {
+        // Fixup path "**" to absolute path.
+        std::string fixedTjMaxPath;
+        try
+        {
+            fixedTjMaxPath = FixupPath(tjMaxPath);
+        }
+        catch (const std::exception& e)
+        {
+            std::cerr << "Failed to fix up tjmax path: " << tjMaxPath
+                      << " error: " << e.what() << "\n";
+            return defaultTjMax;
+        }
+
+        std::ifstream fin(fixedTjMaxPath);
+        if (fin.fail())
+        {
+            std::cerr << "Failed to open Tjmax file: " << fixedTjMaxPath
+                      << "\n";
+            return defaultTjMax;
+        }
+
+        fin >> tjMax;
+        if (fin.fail())
+        {
+            std::cerr << "Failed to read Tjmax value: " << fixedTjMaxPath
+                      << "\n";
+            return defaultTjMax;
+        }
+
+        // Scale the tjMax value.
+        tjMax = tjMax * tjMaxScale;
+    }
+
+    return tjMax;
+}
+
+void writePwm(int pwm, int zoneId, bool isPercentage)
+{
+    std::string cmd = "/usr/bin/writePwm.sh ";
+    cmd += "-z ";
+    cmd += std::to_string(zoneId);
+    if (isPercentage == true)
+    {
+        cmd += " -p ";
+    }
+    else
+    {
+        cmd += " -v ";
+    }
+    cmd += std::to_string(pwm);
+
+    std::array<char, 1024> buffer;
+    std::unique_ptr<FILE, decltype(&pclose)> pipePtr(popen(cmd.c_str(), "r"),
+                                                     pclose);
+    if (pipePtr == nullptr)
+    {
+        std::cerr << "Fan control failed to create popen. Failed to write "
+                  << pwm << " pwm to pwm files.\n";
+    }
+    else
+    {
+        while (fgets(buffer.data(), buffer.size(), pipePtr.get()) != nullptr)
+        {
+            std::cerr << buffer.data() << "\n";
+        }
+        if (ferror(pipePtr.get()))
+        {
+            std::cerr << "Fan control failed to fgets. Can't not get return "
+                         "string from write pwm script.\n";
+        }
+    }
+}
+
 } // namespace pid_control
diff --git a/util.cpp b/util.cpp
index 4ecd8ce..d8e2a41 100644
--- a/util.cpp
+++ b/util.cpp
@@ -54,7 +54,7 @@ void debugPrint(const std::map<std::string, conf::SensorConfig>& sensorConfig,
     {
         std::cout << "\t{" << zone.first << ",\n";
         std::cout << "\t\t{" << zone.second.minThermalOutput << ", ";
-        std::cout << zone.second.failsafePercent << "}\n\t},\n";
+        // std::cout << zone.second.failsafePercent << "}\n\t},\n";
     }
     std::cout << "}\n\n";
     std::cout << "ZoneConfig\n";
diff --git a/util.hpp b/util.hpp
index 032e1ca..d1e68db 100644
--- a/util.hpp
+++ b/util.hpp
@@ -10,10 +10,14 @@
 #include <limits>
 #include <map>
 #include <string>
+#include <unordered_map>
+#include <variant>
 
 namespace pid_control
 {
 
+constexpr double defaultTjMax = 105.0;
+
 void tryRestartControlLoops(void);
 
 /*
@@ -40,6 +44,16 @@ const std::string propertiesintf = "org.freedesktop.DBus.Properties";
  */
 std::string FixupPath(std::string original);
 
+/*
+ * Write specified pwm to pwm files.
+ */
+void writePwm(int pwm, int zoneId = 0, bool isPercentage = false);
+
+/*
+ * Get tjmax value from tjmax path and scale it.
+ */
+double getTjMaxFromPath(const std::string& tjMaxPath, double tjMaxScale);
+
 /*
  * Dump active configuration.
  */
-- 
2.17.1

